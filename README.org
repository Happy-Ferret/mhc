* MHC: Minimal Haskell Compiler

A minimal implementation of Haskell.

* Building

#+BEGIN_EXAMPLE
stack build
#+END_EXAMPLE

* HsYACC & HsLex

** HsYACC

#+BEGIN_EXAMPLE
hsyacc < Parsing.hsy > Parsing.hs
#+END_EXAMPLE

*Parsing.hsy*:

#+BEGIN_EXAMPLE
%module Parsing %where

%start abs

%{
type LAMBDA = ()
type DOT = ()
type LPAREN = ()
type RPAREN = ()
type ID = String

type Id = ID
type Ids = [Id]
type Var = Exp
type App = Exp
type Abs = Exp

data Exp =
    Var ID
  | App Exp Exp
  | Abs ID Exp
  deriving (Eq, Ord, Read, Show)
%}

%%

def rule id :=
  ID

def rule ids :=
  id
| id ids

def rule var :=
  id
| LPAREN abs RPAREN

def rule app :=
  var
| app var

def rule abs :=
  app
| LAMBDA ids DOT app

%%

semanticActions :: Monad m => SemanticActions m
semanticActions = SemanticActions
  { id_implies_ID =
      return
  , ids_implies_id = \id' ->
      return [id']
  , ids_implies_id_ids = \id' ids ->
      return $ id' : ids
  , var_implies_id = \id' ->
      return $ Var id'
  , var_implies_LPAREN_abs_RPAREN = \() exp () ->
      return exp
  , app_implies_var =
      return
  , app_implies_app_var = \exp1 exp2 ->
      return $ App exp1 exp2
  , abs_implies_app =
      return
  , abs_implies_LAMBDA_ids_DOT_app = \() ids () exp ->
      return $ foldr Abs exp ids }
#+END_EXAMPLE

** HsLex

#+BEGIN_EXAMPLE
hslex < Lexing.hsy > Lexing.hs
#+END_EXAMPLE

*Lexing.hsl*:

#+BEGIN_EXAMPLE
%module Lexing %where

%{
import qualified Parsing
%}

%%

case (Initial, "Î»") => saLambda
case (Initial, ".") => saDot
case (Initial, "(") => saLParen
case (Initial, ")") => saRParen
case (Initial, ['a'-'z'|'A'-'Z'|'_']['a'-'z'|'A'-'Z'|'0'-'9'|'_']*) => saId
case (Initial, [' ' '\t' '\n' '\v' '\f' '\r']) => saSpace

%%

semanticActions :: Monad m => SemanticActions m (Maybe Parsing.Token)
semanticActions = SemanticActions
  { saLambda = const $ return $ Just $ Parsing.LAMBDA ()
  , saDot = const $ return $ Just $ Parsing.DOT ()
  , saLParen = const $ return $ Just $ Parsing.LPAREN ()
  , saRParen = const $ return $ Just $ Parsing.RPAREN ()
  , saId = return . Just . Parsing.ID
  , saSpace = const $ return Nothing }
#+END_EXAMPLE

** Main file

#+BEGIN_EXAMPLE
module Main where

import qualified Control.Monad.Identity as Identity
import qualified Data.Maybe             as Maybe
import qualified Lexing
import qualified Parsing

main :: IO ()
main = do
  s <- getContents

  let (tokens0, s') = Identity.runIdentity $ Lexing.runLexing $ Lexing.lex Lexing.semanticActions s
  let tokens = Maybe.catMaybes tokens0

  putStr "tokens: "
  print tokens
  putStr "unread buffer: "
  print s'

  case Identity.runIdentity $ Parsing.parse Parsing.semanticActions tokens of
    Nothing ->
      putStrLn "syntax error."
    Just (result, tokens') -> do
      putStr "result: "
      print result
      putStr "unread tokens: "
      print tokens'
#+END_EXAMPLE

* License

GPLv3.
