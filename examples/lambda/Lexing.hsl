%module Lexing %where

%{
import qualified Control.Monad.State as State
import qualified Control.Monad.Trans as MonadTrans
import qualified Parsing
%}

%%

case (Initial, "Î»") => saLambda
case (Initial, ".") => saDot
case (Initial, "(") => saLParen
case (Initial, ")") => saRParen
case (Initial, ['a'-'z'|'A'-'Z'|'_']['a'-'z'|'A'-'Z'|'0'-'9'|'_']*) => saId
case (Initial, [' ' '\t' '\n' '\v' '\f' '\r']) => saSpace

%%

withPosition :: (Int -> String -> Maybe Parsing.Token) -> String -> Lexing (State.State Int) (Maybe Parsing.Token)
withPosition f yytext = do
  let n = length yytext
  pos <- MonadTrans.lift State.get
  MonadTrans.lift $ State.put $ pos + n
  return $ f pos yytext

semanticActions :: SemanticActions (State.State Int) (Maybe Parsing.Token)
semanticActions = SemanticActions
  { saLambda = withPosition $ const . Just . Parsing.LAMBDA
  , saDot = withPosition $ const . Just . Parsing.DOT
  , saLParen = withPosition $ const . Just . Parsing.LPAREN
  , saRParen = withPosition $ const . Just . Parsing.RPAREN
  , saId = withPosition $ curry $ Just . Parsing.ID
  , saSpace = withPosition $ const $ const Nothing }
